
model_name: "alexnet" # Which model to use. Currently only cnn_dense and alexnet is supperted. Needed for live.
pretrained_model_name: "best_alexnet_epoch_30.hdf5" # Name of the weights file to be loaded. Needed for live.
seed: 42 # Seed for reproducibility
predict: False # Whether or not to make predictions. Needed for live.
device: "cuda"
num_workers: 12 # Number of workers for the dataloader. Needed for live.
run_id: "test"


project_paths:
  output_folder: output/ # Where plots and csvs are stored. Not needed for live
  output_folders:
    data_csv: data.csv # Where the data csv is stored. Not needed for live. # TODO Is this even used?
    model_save_folder: models/ # Where models are and will be saved. Needed for live
    logs_folder: logs/ # Where logs are stored. Not needed for live. Currently unused
    predictions_folder: predictions/ # Redundant output directory. Not needed for live
    plots_folder: plots/ # Another redundant output directory. Not needed for live
  live_test_path: live_test/ # Where the live data plots are stored. Needed for live, but not final version.
  scaler_path: saved_scalers/ # Where fitted scalers are stored. Only needed for live if global scaler is used.


data_paths: # Needed for live
  data_path: data/ # Directory for training, validation and test data. Not needed for live
  loaded_path: data/loaded/ # Where the loaded data is stored. Not needed for live
  map_folder: data/maps/ # Where the maps are stored. Not needed for live
  metadata_folder: metadata/ # Where the metadata is stored. Not needed for live

data: # None of these are needed for live
  debug: True # If true, only 10% of the data is loaded
  include_induced: True # Whether or not induced events are included (as earthquake)
  load_filtered: True # Whether or not to load filtered data, or unfilitered data.
  load_testset: False # Whether or not to load the test set
  model_threshold: 0.5 # Threshold for model prediction to be considered a positive prediction
  val_years: [2013] # Years included in the validation set
  test_years: [2014] # Years included in the test set
  SNR_threshold: 0.5 # Threshold for event to be included in dataset
  coda_factor: 1.4
  default_length_seconds: 180 
  sample_rate: 40 # Sample rate of the data


live: # Needed for live
  live: True # Alters the pipeline to be used for live data
  array: "ARCES" # Which array to use. Currently only ARCES is supported
  step: 5 # How many seconds between each prediction
  length: 240 # Length of the data to be used for each prediction (seconds)
  edge: 10 # Additional seconds of data to load, which will be cut due to tapering.
  delay: 5 # TODO: Figure out if this is used.
  event_buffer: 30 # Number of seconds to load before and after the area of interest, determined by length and pick.
  p_vel: 6.45 # Artificial velocity of P waves. Used to make beams.
  s_vel: 3.70 # Artificial velocity of S waves. Used to make beams.

filters: # Needed for live
  use_filters: True # Whether or not to use filters
  detrend: True # Whether or not to detrend the data
  taper: True # Whether or not to taper the data
  taper_max_percentage: 0.05 # Maximum percentage of the data to be tapered
  highpass_or_bandpass: bandpass # Whether to use a highpass or bandpass filter
  band_kwargs: 
    min: 2 # Minimum frequency of the bandpass filter
    max: 8 # Maximum frequency of the bandpass filter
  high_kwargs:
    high_freq: 1.0 # High frequency of the highpass filter
  
wandb:
  active: True
  project: "arces_classification"
  entity: "norsar_ai"

callbacks: # Not needed for live
  early_stopping_patience: 7 # Number of epochs without improvement before early stopping
  umap: False # Whether or not to use UMAP
  umap_interval: 5 # Number of epochs between each UMAP plot
  wandb_n_batches_per_update: 50 # Number of batches between each wandb update # TODO: Is this used anymore?
  reduce_lr_patience: 1 # Number of epochs without improvement before reducing learning rate

scaling: # Needed for live
  scaler_type: minmax # Which scaler to use. Currently only minmax is supported for live, as other scalers are not fitted.
  per_channel: False # Whether or not to scale each channel individually
  global_or_local: local # Whether or not to use a global scaler. Currently only local is supported for live as global isn't fitted.

augment: # Not needed for live
  random_crop_kwargs:
    timesteps: 4000 # Number of final timesteps
    end_buffers: 50 # Minimum number of timesteps before or after the end of the event.
    must_include_entire_event: true # Whether or not the entire event must be included in the crop
    inclusion_proportion: 0.5 # Proportion of the event that must be included in the crop if must_include is false
    min_event_length: 20 # Minimum length in seconds an event can be
  zero_channel: True # Whether or not to zero out a random channel
  zero_channel_kwargs:
    prob: 0.1 # Probability of zeroing out a channel
  add_gap: False # Whether or not to add a gap to the data # TODO: This augemntation does not work as expected.
  add_gap_kwargs:
    prob: 0 # Probability of adding a gap
    max_size: 0.01
  add_noise: True # Whether or not to add noise to the data
  add_noise_kwargs:
    prob: 0.2 # Probability of adding noise
    noise_std: 0.1 # Standard deviation of the noise
  taper: True # Whether or not to taper the data
  taper_kwargs:
    prob: 1 # Probability of tapering the data
    alpha: 0.04 # Alpha value of the taper
  bandpass: True
  bandpass_kwargs:
    prob: 0.5
    default_min: 2
    default_max: 8
    optional_min: [1, 3, 4]
    optional_max: [6, 10, 14, 21]

optimizer: # Not needed for live
  max_epochs: 100 # Maximum number of epochs
  batch_size: 128 # Batch size
  optimizer: adam # Which optimizer to use
  optimizer_kwargs: 
    warmup: False # Whether or not to use warmup
    max_lr: 0.0001 # Maximum learning rate
    min_lr: 0.000005 # Minimum learning rate
    weight_decay: 1e-6 # Weight decay
  scheduler:
    use_scheduler: True # Whether or not to use a scheduler
    warmup: False # Whether or not to use warmup
    warmup_epochs: 5 # Number of warmup epochs
    scheduler_type: "cosine" # Which scheduler to use. So far only cosine available.

